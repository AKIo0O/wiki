
var Handlebars = require("handlebars");


function Class(){
    this.events = {};
}

Class.prototype = {

    trigger: function(name, context){
        var event = this.events[name];
        if(event) return event.call(this, context); 
        return context;
    },

    on: function(name, handler){
        this.events[name] = handler;
    }
};


T = {

    type: function(o){
        return Object.prototype.toString.call(o).slice(8, -1);
    },

    extend: function(sub, sup){
        var f = new Function();
        f.prototype = sup.prototype;
        sub.prototype = new f();
        sub.prototype.constructor = sub;
    },

    mixin: function(target, options, more){

        if(more) T.mixin(target, more);
        for(var name in options){
            if(T.type(options[name]) == "Object"){
                target[name] = {};
                T.mixin(target[name], options[name]);
            }else if(Array.isArray(options[name])){
                target[name] = [].slice.call(options[name]);
            }else{
                target[name] = options[name];
            }
        }
        return target;
    },

    each: function(arr, handler){

        if(Array.isArray(arr)){
            for(var i =0, l = arr.length; i < l; i++)
                handler.call(arr[i], arr[i],i);
        }else{
            handler.call(arr, arr);
        }
    }
};


var Tempalte = function(){
    Class.call(this);
    this.complielist = [];
    this.complied = false;
};

T.extend(Tempalte, Class);

Tempalte.prototype = {

    compile: function(){
        var me = this;

        if(!me.compilelist) console.error("无编译列表");

        T.each(me.compilelist, function(key){
            if(typeof me[key] == "string")
                me[key] = Handlebars.compile(me[key]);
        });
        me.compiled = true;
    },

    run: function(data){
        var html = "";
        if(!this.compiled) this.compile();
        html = this.process(data);
        // html = this.trigger("beforeend", html);
        return html;
    },
};

T.wrap = function(className, tagName){

    var string  = ["<",tagName, " class='" +className +"'", ">"].join("");

    if(className.indexOf(".") == -1){
        tagName = className;
        string  = ["<",tagName, ">"].join("")
    }

    var tagName = tagName || "div",
        subfix  = ["</",tagName,">"].join("");

    return function(content){
        return string + content + subfix;
    };
};


T.create = function(opts, tagName){
    if(tagName) return T.mixin(new Tempalte, opts, new Element(tagName));
    return T.mixin(new Tempalte, opts);
};

var Element = function(tagName){

    this.tagName = tagName;
    this.attributes = {};
    this.className = "";
    this.dataset = {};
    this.html = "";
    this.style = "";
    this.blocks = [];
};

Element.prototype = {

    setAttribute: function(key, value){
        this.attributes[key] = value;
    },

    getAttribute: function(key){
        return this.attributes[key];        
    },

    innerHTML: function(html){
        if(!html) return this.html;
        this.html = html;
    },

    setStyle: function(css){
        this.attributes.style = css;
    },

    toString: function(){
        return this.prefix() + this.html + this.subfix();
    },

    append: function(html){
        this.html = this.html + html;
    },

    appendbegin: function(html){
        this.html = html + this.html;
    },

    addBlock: function(block){
        if(arguments.length > 1 ){
            var b = [].slice.call(arguments);
            if(Array.isArray(block)) b = block;
            return [].push.apply(this.blocks, b);
        }
        this.blocks.push(block);
    },

    getBlockString: function(){
        var html = "";
        T.each(this.blocks, function(block){
            
            html += block.run();
        });
        this.html = html;
        return this.toString();
    },

    clear: function(){
        this.html="";
    },

    prefix: function(){
        
        var attr = ' ';

        for(var set in this.dataset){
            this.attributes['data-'+set] = this.dataset[set];
        }

        for(var name in this.attributes){
            attr += name + '="' + this.attributes[name] + '"'; 
        }

        return ['<' + this.tagName, attr, '>'].join('');
    },

    subfix: function(){

        return '<'+this.tagName + '>';
    }
};

var fs = require("fs");

var importTpl = function(name){
    return fs.readFileSync('./views/tpls/'+name).toString();
};

T.createtpl = function(name){
    
    return T.create({

        tpl: importTpl(name+'.tpl'),

        update: function(){
            this.tpl = importTpl(name+'.tpl');
            this.compile();
        },

        datas: {},

        compilelist: ['tpl'],

        process: function(data){
            if(this.reset) this.datas = {};
            if(data) T.mixin(this.datas, data);
            if(global.debug) this.update();
            return this.tpl(this.datas);
        },

        chunked: function(callback, req) {
            callback(this.run(this.datas));
        },

        reset: true
    }, name);
};


exports.T = T;